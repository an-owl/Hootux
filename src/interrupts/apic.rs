use alloc::boxed::Box;
use apic_structures::registers::ApicError;
use crate::interrupts::apic::apic_structures::apic_types::TimerMode;

pub mod xapic;
pub mod apic_structures;

/// Contains the cpus local APIC. Uses mutex in case of mischievous r/w
#[thread_local]
pub static LOCAL_APIC: spin::Mutex<Option<Box<dyn Apic>>> = spin::Mutex::new(None);


/// Trait for control over the Local Advanced Programmable Interrupt Controller
///
/// #LVT Entry
/// These registers contain interrupt configuration information. All registers contain an 8bit
/// vector and a mask bit. The vector may not be less than 16, however it should not be lower than 32
/// because vectors 0..32 are used for exception handling and may cause unwanted behaviour.
/// When set the mask bit will prevent an interrupt from being generated by the interrupt controller
pub trait Apic: crate::time::Timer {

    unsafe fn set_enable(&mut self, enable: bool);

    unsafe fn init_err(&mut self, vector: u8, mask: bool);

    unsafe fn init_timer(&mut self, vector: u8, mask: bool);

    unsafe fn set_timer(&mut self, mode: TimerMode, time: u32);

    /// Declares that the current interrupt has been handled.
    /// this should be the last thing called before the end of an interrupt handler.
    fn declare_eoi(&mut self);

    /// Gets the current error and clears the error register.
    fn get_err(&self) -> ApicError;

    /// Calibrates the local APIC timer to [TARGET_FREQ].
    /// `test_time` is the time used for the clock until the test is complete.
    ///
    /// Before this fn returns it will mask the timer. This will need to be re-enabled after
    /// changing the interrupt handler to a permanent one.
    ///
    /// #Panics
    ///
    /// Implementations should panic if `super::IHC\[vec\]` is already occupied
    fn begin_calibration(&mut self, test_time: u32, vec: u8);
}

const TARGET_FREQ: u32 = 300;
const TARGET_PERIOD: u64 = (1000000000f64*(1 as f64/ TARGET_FREQ as f64)) as u64; // no touch

//#[thread_local]
static mut CALI: Option<u64> = None;

/// Interrupt handler used for calibrating the local APIC timer.
fn handle_timer_and_calibrate(){
    unsafe { CALI = Some(crate::time::get_sys_time()) }
    crate::kernel_statics::fetch_local().local_apic.as_mut().unwrap().declare_eoi();
}

/// Default timer handler. Updates system time then exits.
fn timer_handler() {
    crate::time::update_timer();
    crate::kernel_statics::fetch_local().local_apic.as_mut().unwrap().declare_eoi()
}

/// Calibrates local APIC and sets interrupt handler.
/// This is temporary and required because of the privacy of [crate::kernel_statics]
pub fn cal_and_run(time: u32, vec: u8) {
    crate::kernel_statics::fetch_local().local_apic.as_mut().unwrap().begin_calibration(time,vec);

    unsafe {
        super::vector_tables::IHR.set(vec, timer_handler).expect("???");
        crate::kernel_statics::fetch_local().local_apic.as_mut().unwrap().init_timer(vec,false);
    };
}